/*
 * RNDTBL Query Language Lexer (Lex/Flex)
 * 
 * Lexical analyzer for the RNDTBL graph query language.
 * Compile with: flex rndtbl.l
 * 
 * This tokenizes RNDTBL query input for the Yacc/Bison parser.
 */

%{
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "rndtbl.tab.h"  /* Generated by bison -d rndtbl.y */

/* Track line and column numbers for error reporting */
int yyline = 1;
int yycolumn = 1;

/* Update column position */
#define YY_USER_ACTION \
    yylloc.first_line = yylloc.last_line = yyline; \
    yylloc.first_column = yycolumn; \
    yylloc.last_column = yycolumn + yyleng - 1; \
    yycolumn += yyleng;

/* String buffer for handling escape sequences */
static char string_buf[4096];
static char *string_buf_ptr;

%}

/* Options */
%option noyywrap
%option case-insensitive
%option yylineno

/* Start conditions for strings and comments */
%x STRING
%x COMMENT

/* Common patterns */
DIGIT       [0-9]
LETTER      [a-zA-Z_]
ALPHANUM    [a-zA-Z0-9_]
WHITESPACE  [ \t\r]
NEWLINE     \n

%%

    /* ====================================================================== */
    /* Whitespace and Comments */
    /* ====================================================================== */

{WHITESPACE}+       { /* Skip whitespace */ }
{NEWLINE}           { yyline++; yycolumn = 1; }

"/*"                { BEGIN(COMMENT); }
<COMMENT>"*/"       { BEGIN(INITIAL); }
<COMMENT>{NEWLINE}  { yyline++; yycolumn = 1; }
<COMMENT>.          { /* Skip comment content */ }

"//".*              { /* Skip single-line comments */ }

    /* ====================================================================== */
    /* Keywords (case-insensitive) */
    /* ====================================================================== */

MATCH               { return MATCH; }
CREATE              { return CREATE; }
MERGE               { return MERGE; }
DELETE              { return DELETE; }
DETACH              { return DETACH; }
SET                 { return SET; }
REMOVE              { return REMOVE; }
RETURN              { return RETURN; }
WITH                { return WITH; }
WHERE               { return WHERE; }
ORDER               { return ORDER; }
BY                  { return BY; }
LIMIT               { return LIMIT; }
SKIP                { return SKIP; }
AS                  { return AS; }
ASC                 { return AS; }  /* Reuse AS token */
DESC                { /* Could define separate DESC token */ }
DISTINCT            { return DISTINCT; }

    /* ====================================================================== */
    /* Logical Operators */
    /* ====================================================================== */

AND                 { return AND; }
OR                  { return OR; }
NOT                 { return NOT; }
IN                  { return IN; }

    /* ====================================================================== */
    /* String Operators */
    /* ====================================================================== */

CONTAINS            { return CONTAINS; }
STARTS              { return STARTS; }
ENDS                { return ENDS; }

    /* ====================================================================== */
    /* Aggregate Functions */
    /* ====================================================================== */

COUNT               { return COUNT; }
SUM                 { return SUM; }
AVG                 { return AVG; }
MIN                 { return MIN; }
MAX                 { return MAX; }

    /* ====================================================================== */
    /* Utility Functions */
    /* ====================================================================== */

SIZE                { return SIZE; }
LENGTH              { return LENGTH; }
TYPE                { return TYPE_FUNC; }
ID                  { return ID_FUNC; }
NOW                 { return NOW; }
TIMESTAMP           { return TIMESTAMP_FUNC; }
NODES               { return NODES; }
RELATIONSHIPS       { return RELATIONSHIPS; }
PATH                { return PATH; }

    /* ====================================================================== */
    /* CASE Expression */
    /* ====================================================================== */

CASE                { return CASE; }
WHEN                { return WHEN; }
THEN                { return THEN; }
ELSE                { return ELSE; }
END                 { return END; }

    /* ====================================================================== */
    /* Literals */
    /* ====================================================================== */

TRUE                { return TRUE_TOKEN; }
FALSE               { return FALSE_TOKEN; }
NULL                { return NULL_TOKEN; }

    /* ====================================================================== */
    /* Numbers */
    /* ====================================================================== */

{DIGIT}+            { 
                        yylval.integer = atoi(yytext); 
                        return INTEGER; 
                    }

{DIGIT}+"."{DIGIT}+ |
{DIGIT}+"."{DIGIT}+[eE][+-]?{DIGIT}+ |
{DIGIT}+[eE][+-]?{DIGIT}+ {
                        yylval.floating = atof(yytext);
                        return FLOAT;
                    }

    /* ====================================================================== */
    /* String Literals */
    /* ====================================================================== */

\"                  { 
                        string_buf_ptr = string_buf; 
                        BEGIN(STRING); 
                    }

<STRING>\"          { 
                        BEGIN(INITIAL);
                        *string_buf_ptr = '\0';
                        yylval.string = strdup(string_buf);
                        return STRING;
                    }

<STRING>\\n         { *string_buf_ptr++ = '\n'; }
<STRING>\\t         { *string_buf_ptr++ = '\t'; }
<STRING>\\r         { *string_buf_ptr++ = '\r'; }
<STRING>\\b         { *string_buf_ptr++ = '\b'; }
<STRING>\\f         { *string_buf_ptr++ = '\f'; }
<STRING>\\\"        { *string_buf_ptr++ = '"'; }
<STRING>\\\'        { *string_buf_ptr++ = '\''; }
<STRING>\\\\        { *string_buf_ptr++ = '\\'; }

<STRING>\\[0-7]{1,3} {
                        /* Octal escape sequence */
                        int result;
                        sscanf(yytext + 1, "%o", &result);
                        if (result > 0xff) {
                            fprintf(stderr, "Error: octal escape out of range\n");
                        }
                        *string_buf_ptr++ = result;
                    }

<STRING>\\x[0-9a-fA-F]{1,2} {
                        /* Hex escape sequence */
                        int result;
                        sscanf(yytext + 2, "%x", &result);
                        *string_buf_ptr++ = result;
                    }

<STRING>\n          { 
                        fprintf(stderr, "Error: unterminated string\n");
                        yyline++;
                        yycolumn = 1;
                    }

<STRING>.           { *string_buf_ptr++ = *yytext; }

'[^']*'             {
                        /* Single-quoted string (alternative syntax) */
                        yylval.string = strndup(yytext + 1, yyleng - 2);
                        return STRING;
                    }

    /* ====================================================================== */
    /* Identifiers */
    /* ====================================================================== */

{LETTER}{ALPHANUM}* { 
                        yylval.string = strdup(yytext); 
                        return IDENTIFIER; 
                    }

`[^`]+`             {
                        /* Backtick-quoted identifier (can contain spaces/special chars) */
                        yylval.string = strndup(yytext + 1, yyleng - 2);
                        return IDENTIFIER;
                    }

    /* ====================================================================== */
    /* Operators and Punctuation */
    /* ====================================================================== */

"<-"                { return ARROW_LEFT; }
"->"                { return ARROW_RIGHT; }
"<>"                { return NE; }
"!="                { return NE; }
"<="                { return LE; }
">="                { return GE; }
"<"                 { return LT; }
">"                 { return GT; }
"="                 { return EQ; }

"+"                 { return '+'; }
"-"                 { return '-'; }
"*"                 { return '*'; }
"/"                 { return '/'; }
"%"                 { return '%'; }
"^"                 { return '^'; }

"("                 { return '('; }
")"                 { return ')'; }
"["                 { return '['; }
"]"                 { return ']'; }
"{"                 { return '{'; }
"}"                 { return '}'; }

","                 { return ','; }
";"                 { return ';'; }
":"                 { return ':'; }
"."                 { return '.'; }

    /* ====================================================================== */
    /* Error Handling */
    /* ====================================================================== */

.                   { 
                        fprintf(stderr, "Lexical error at line %d, column %d: unexpected character '%s'\n",
                                yyline, yycolumn, yytext);
                    }

%%

/*
 * Additional C code
 */

/* Initialize the lexer */
void init_lexer(void) {
    yyline = 1;
    yycolumn = 1;
}

/* Get current position for error reporting */
void get_position(int *line, int *column) {
    *line = yyline;
    *column = yycolumn;
}

/* Example usage */
#ifdef LEXER_MAIN
int main(int argc, char **argv) {
    if (argc > 1) {
        FILE *f = fopen(argv[1], "r");
        if (!f) {
            fprintf(stderr, "Could not open file: %s\n", argv[1]);
            return 1;
        }
        yyin = f;
    }
    
    printf("RNDTBL Lexical Analyzer\n");
    printf("=======================\n\n");
    
    int token;
    while ((token = yylex()) != 0) {
        printf("Token: %d", token);
        
        switch (token) {
            case IDENTIFIER:
            case STRING:
                printf(" (value: %s)", yylval.string);
                break;
            case INTEGER:
                printf(" (value: %d)", yylval.integer);
                break;
            case FLOAT:
                printf(" (value: %f)", yylval.floating);
                break;
        }
        
        printf(" at line %d, column %d\n", yyline, yycolumn);
    }
    
    if (argc > 1) {
        fclose(yyin);
    }
    
    return 0;
}
#endif
