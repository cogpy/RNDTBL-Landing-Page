/*
 * RNDTBL Synchronization Specification (Z++)
 * Defines synchronization, conflict resolution, and distributed operations
 */

use CORE_TYPES
use GRAPH

// ============================================================================
// CRDT (Conflict-Free Replicated Data Type) Base
// ============================================================================

class CRDT[T]
  value : T
  replica_id : ID
  timestamp : Timestamp
  vector_clock : ID ‚Ü¶ ‚Ñï
  
  invariant
    replica_id ‚àà dom vector_clock
    vector_clock(replica_id) ‚â• 0
    
  // Merge two CRDT instances
  merge(other : CRDT[T]) : CRDT[T]
    post
      result.vector_clock = 
        {id : (dom self.vector_clock ‚à™ dom other.vector_clock) ‚Ä¢
          id ‚Ü¶ max(self.vector_clock(id), other.vector_clock(id))}
      
  // Compare vector clocks
  happensBefore(other : CRDT[T]) : ùîπ
    return
      ‚àÄ id : dom self.vector_clock ‚Ä¢
        self.vector_clock(id) ‚â§ other.vector_clock(id) ‚àß
      ‚àÉ id : dom self.vector_clock ‚Ä¢
        self.vector_clock(id) < other.vector_clock(id)
        
  // Check if concurrent
  concurrent(other : CRDT[T]) : ùîπ
    return
      ¬¨self.happensBefore(other) ‚àß ¬¨other.happensBefore(self)
      
end CRDT

// ============================================================================
// LWW (Last-Write-Wins) Register
// ============================================================================

class LWWRegister extends CRDT[Content]
  
  // Update value
  update(newValue : Content, replicaId : ID) : LWWRegister
    post
      self.value = newValue
      self.replica_id = replicaId
      self.timestamp = now()
      self.vector_clock(replicaId) = self.vector_clock(replicaId) + 1
      
  // Merge with another register
  override merge(other : LWWRegister) : LWWRegister
    post
      // Last write wins based on timestamp, then replica_id
      result.timestamp > other.timestamp ‚áí result = self
      result.timestamp < other.timestamp ‚áí result = other
      result.timestamp = other.timestamp ‚áí
        (self.replica_id > other.replica_id ‚áí result = self
         self.replica_id ‚â§ other.replica_id ‚áí result = other)
      
      // Merge vector clocks
      result.vector_clock = 
        {id : (dom self.vector_clock ‚à™ dom other.vector_clock) ‚Ä¢
          id ‚Ü¶ max(self.vector_clock(id), other.vector_clock(id))}
          
end LWWRegister

// ============================================================================
// OR-Set (Observed-Remove Set)
// ============================================================================

class ORSet[T] extends CRDT[‚Ñô T]
  elements : T ‚Ü¶ ‚Ñô(ID √ó Timestamp)  // Element ‚Üí {(replica, timestamp)}
  
  invariant
    value = dom elements
    
  // Add element
  add(element : T, replicaId : ID) : ORSet[T]
    post
      let tag = (replicaId, now()) in
        self.elements' = self.elements ‚äï 
          {element ‚Ü¶ (self.elements(element) ‚à™ {tag})}
        self.vector_clock'(replicaId) = self.vector_clock(replicaId) + 1
        
  // Remove element
  remove(element : T, observedTags : ‚Ñô(ID √ó Timestamp)) : ORSet[T]
    pre
      element ‚àà dom self.elements
      observedTags ‚äÜ self.elements(element)
    post
      self.elements' = self.elements ‚äï
        {element ‚Ü¶ (self.elements(element) \ observedTags)}
        
  // Merge two sets
  override merge(other : ORSet[T]) : ORSet[T]
    post
      result.elements = 
        {e : (dom self.elements ‚à™ dom other.elements) ‚Ä¢
          e ‚Ü¶ (self.elements(e) ‚à™ other.elements(e))}
      
      // Merge vector clocks
      result.vector_clock = 
        {id : (dom self.vector_clock ‚à™ dom other.vector_clock) ‚Ä¢
          id ‚Ü¶ max(self.vector_clock(id), other.vector_clock(id))}
          
end ORSet

// ============================================================================
// Synchronization Manager
// ============================================================================

class SyncManager
  local_graph : Graph
  replica_id : ID
  peers : ‚Ñô PeerConnection
  pending_changes : seq Change
  sync_log : seq SyncEvent
  
  invariant
    replica_id ‚â† null
    
  // Push changes to peers
  pushChanges(peerId : ID) : Result[ùîπ]
    pre
      ‚àÉ p : peers ‚Ä¢ p.peer_id = peerId
      pending_changes ‚â† ‚ü®‚ü©
    post
      let peer = (Œº p : peers ‚Ä¢ p.peer_id = peerId)
          changes_to_send = filterChanges(pending_changes, peer.last_sync)
      in
        sendToPeer(peer, changes_to_send)
        peer.last_sync' = now()
        result.success = true
        
  // Pull changes from peer
  pullChanges(peerId : ID) : Result[seq Change]
    pre
      ‚àÉ p : peers ‚Ä¢ p.peer_id = peerId
    post
      let peer = (Œº p : peers ‚Ä¢ p.peer_id = peerId)
          remote_changes = receiveFromPeer(peer, local_graph.last_modified)
      in
        result.success = true
        result.data = remote_changes
        
  // Apply remote changes
  applyChanges(changes : seq Change) : Result[ùîπ]
    pre
      changes ‚â† ‚ü®‚ü©
    post
      ‚àÄ c : changes ‚Ä¢
        applyChange(c)
      result.success = true
      
  // Apply single change
  applyChange(change : Change) : Result[ùîπ]
    post
      change.type = create ‚áí 
        local_graph.addNode(createNodeFromChange(change))
        
      change.type = update ‚áí
        let node = local_graph.nodes(change.target) in
          resolveConflict(node, change)
          
      change.type = delete ‚áí
        local_graph.removeNode(change.target)
        
      change.type = link ‚áí
        local_graph.addEdge(createEdgeFromChange(change))
        
      change.type = unlink ‚áí
        local_graph.removeEdge(change.target)
        
      result.success = true
      
  // Resolve conflicting changes
  resolveConflict(node : Node, change : Change) : Node
    post
      // Use LWW strategy by default
      change.timestamp > node.metadata.modified ‚áí
        result = applyChangeToNode(node, change)
        
      change.timestamp < node.metadata.modified ‚áí
        result = node  // Ignore older change
        
      change.timestamp = node.metadata.modified ‚áí
        // Use replica_id as tiebreaker
        change.user > node.metadata.author ‚áí
          result = applyChangeToNode(node, change)
        change.user ‚â§ node.metadata.author ‚áí
          result = node
          
  // Full synchronization with peer
  fullSync(peerId : ID) : Result[ùîπ]
    post
      // Push local changes
      pushChanges(peerId)
      
      // Pull remote changes
      let remote_changes = pullChanges(peerId) in
        applyChanges(remote_changes.data)
        
      // Verify consistency
      verifyConsistency(peerId)
      
      result.success = true
      
  // Verify graph consistency with peer
  verifyConsistency(peerId : ID) : ùîπ
    post
      let peer_hash = getPeerGraphHash(peerId)
          local_hash = computeGraphHash(local_graph)
      in
        result = (peer_hash = local_hash)
        
  // Compute graph hash for consistency check
  computeGraphHash(graph : Graph) : String
    post
      let node_hashes = {n : dom graph.nodes ‚Ä¢ 
                         hash(graph.nodes(n))}
          edge_hashes = {e : dom graph.edges ‚Ä¢ 
                         hash(graph.edges(e))}
      in
        result = hash(node_hashes ‚à™ edge_hashes)
        
end SyncManager

// ============================================================================
// Peer Connection
// ============================================================================

class PeerConnection
  peer_id : ID
  url : String
  status : ConnectionStatus
  last_sync : Timestamp
  trust_level : TrustLevel
  sync_topics : ‚Ñô TopicID
  
  invariant
    peer_id ‚â† null
    url ‚â† ""
    
  // Connect to peer
  connect() : Result[ùîπ]
    pre
      status = disconnected
    post
      // Establish connection
      status' = connected
      result.success = true
      
  // Disconnect from peer
  disconnect() : Result[ùîπ]
    pre
      status = connected
    post
      status' = disconnected
      result.success = true
      
  // Send data to peer
  send(data : String) : Result[ùîπ]
    pre
      status = connected
    post
      // Network send operation
      result.success = true
      
  // Receive data from peer
  receive() : Result[String]
    pre
      status = connected
    post
      result.success = true
      // result.data contains received data
      
end PeerConnection

ConnectionStatus ::= disconnected | connecting | connected | error

TrustLevel ::= 
  | full          // Full read/write access
  | readWrite     // Can read and contribute
  | readOnly      // Can only read
  | restricted    // Limited topics only

// ============================================================================
// Sync Event
// ============================================================================

class SyncEvent
  id : ID
  timestamp : Timestamp
  event_type : SyncEventType
  peer_id : ID
  changes_count : ‚Ñï
  success : ùîπ
  error : String
  
  invariant
    success ‚áí error = ""
    ¬¨success ‚áí error ‚â† ""
    changes_count ‚â• 0
end SyncEvent

SyncEventType ::= 
  | push_started
  | push_completed
  | pull_started
  | pull_completed
  | conflict_detected
  | conflict_resolved
  | sync_error

// ============================================================================
// Federation Protocol
// ============================================================================

class FederationProtocol
  
  // Handshake with peer
  handshake(peer : PeerConnection) : Result[FederationAgreement]
    post
      // Exchange capabilities and trust levels
      result.success = true
      result.data.peer_id = peer.peer_id
      result.data.supported_features = getSupportedFeatures()
      result.data.sync_topics = peer.sync_topics
      
  // Negotiate sync strategy
  negotiateSync(peer : PeerConnection) : SyncStrategy
    post
      peer.trust_level = full ‚áí result = bidirectional
      peer.trust_level = readWrite ‚áí result = bidirectional
      peer.trust_level = readOnly ‚áí result = pull_only
      peer.trust_level = restricted ‚áí result = filtered
      
end FederationProtocol

class FederationAgreement
  peer_id : ID
  supported_features : ‚Ñô String
  sync_topics : ‚Ñô TopicID
  sync_strategy : SyncStrategy
  established : Timestamp
end FederationAgreement

SyncStrategy ::= 
  | bidirectional  // Full two-way sync
  | pull_only      // Only pull from peer
  | push_only      // Only push to peer
  | filtered       // Selective sync based on filters

// ============================================================================
// Conflict Resolution Strategies
// ============================================================================

ConflictStrategy ::=
  | lastWriteWins      // Use timestamp to decide
  | firstWriteWins     // Keep original
  | manual             // Require manual resolution
  | merge              // Attempt to merge changes
  | custom             // Custom resolution function

class ConflictResolver
  strategy : ConflictStrategy
  
  // Resolve conflict between two nodes
  resolve(local : Node, remote : Node) : Node
    post
      strategy = lastWriteWins ‚áí
        result = (local.metadata.modified > remote.metadata.modified) 
                 ? local : remote
                 
      strategy = firstWriteWins ‚áí
        result = (local.metadata.created < remote.metadata.created)
                 ? local : remote
                 
      strategy = merge ‚áí
        result = mergeNodes(local, remote)
        
      strategy = manual ‚áí
        result = ‚ä•  // Requires user intervention
        
  // Merge two nodes
  mergeNodes(local : Node, remote : Node) : Node
    post
      // Merge content
      result.content = mergeContent(local.content, remote.content)
      
      // Combine contributors
      result.metadata.contributors = 
        local.metadata.contributors ‚à™ remote.metadata.contributors
        
      // Use latest timestamp
      result.metadata.modified = 
        max(local.metadata.modified, remote.metadata.modified)
        
      // Increment version
      result.metadata.version = 
        max(local.metadata.version, remote.metadata.version) + 1
        
end ConflictResolver

// ============================================================================
// Utility Functions
// ============================================================================

// Filter changes based on last sync time
filterChanges(changes : seq Change, since : Timestamp) : seq Change
  post
    result = ‚ü®c : changes | c.timestamp > since‚ü©

// Create node from change
createNodeFromChange(change : Change) : Node
  pre
    change.type = create
  post
    result.content = change.after
    result.metadata.author = change.user
    result.metadata.created = change.timestamp

// Create edge from change  
createEdgeFromChange(change : Change) : Edge
  pre
    change.type = link
  post
    result.metadata.author = change.user
    result.metadata.created = change.timestamp
