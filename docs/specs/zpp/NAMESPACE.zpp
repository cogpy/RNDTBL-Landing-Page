/*
 * RNDTBL Namespace Specification (Z++)
 * Defines Plan9-inspired namespace model for distributed cognition
 */

use CORE_TYPES
use GRAPH

// ============================================================================
// File System Abstraction
// ============================================================================

// File types in the namespace
FileType ::= regular | directory | symlink | special

class File
  path : String
  type : FileType
  size : â„•
  permissions : Permissions
  owner : UserID
  created : Timestamp
  modified : Timestamp
  content : Content
  
  invariant
    path â‰  ""
    type = directory â‡’ size = 0
    type = regular â‡’ content â‰  âŠ¥
    size â‰¥ 0
    
  // Read file content
  read(offset : â„•, count : â„•) : Result[String]
    pre
      type = regular
      offset â‰¤ size
    post
      result.success = true
      result.data = substring(content.data, offset, offset + count)
      
  // Write file content
  write(offset : â„•, data : String) : Result[â„•]
    pre
      type = regular
      hasPermission(current_user, self, write)
    post
      self.content.data' = 
        substring(self.content.data, 0, offset) + 
        data + 
        substring(self.content.data, offset + |data|, size)
      self.modified' = now()
      self.size' = |self.content.data'|
      result.success = true
      result.data = |data|
      
end File

class Permissions
  owner_read : ğ”¹
  owner_write : ğ”¹
  owner_exec : ğ”¹
  group_read : ğ”¹
  group_write : ğ”¹
  group_exec : ğ”¹
  other_read : ğ”¹
  other_write : ğ”¹
  other_exec : ğ”¹
  
  // Convert to Unix-style mode
  toMode() : â„•
    post
      result = 
        (owner_read ? 400 : 0) +
        (owner_write ? 200 : 0) +
        (owner_exec ? 100 : 0) +
        (group_read ? 40 : 0) +
        (group_write ? 20 : 0) +
        (group_exec ? 10 : 0) +
        (other_read ? 4 : 0) +
        (other_write ? 2 : 0) +
        (other_exec ? 1 : 0)
        
end Permissions

// ============================================================================
// Namespace Structure
// ============================================================================

class Namespace
  root : String
  files : String â†¦ File
  mounts : String â†¦ Namespace
  
  invariant
    "/" âˆˆ dom files
    files("/").type = directory
    
    // All parent directories exist
    âˆ€ path : dom files â€¢
      parentPath(path) âˆˆ dom files âˆ¨ parentPath(path) = ""
      
    // No cycles in mounts
    Â¬âˆƒ path : dom mounts â€¢ mountCycle(path, mounts(path))
    
  // Look up file by path
  lookup(path : String) : Result[File]
    post
      path âˆˆ dom files â‡’
        result.success = true âˆ§ result.data = files(path)
        
      path âˆ‰ dom files â‡’
        // Check if path is in mounted namespace
        let mount_point = longestMountPrefix(path) in
          mount_point â‰  "" â‡’
            let relative_path = path - mount_point in
              result = mounts(mount_point).lookup(relative_path)
          mount_point = "" â‡’
            result.success = false âˆ§ result.error = "File not found"
            
  // Create file
  create(path : String, type : FileType, content : Content) : Result[File]
    pre
      path âˆ‰ dom files
      parentPath(path) âˆˆ dom files
      files(parentPath(path)).type = directory
    post
      let new_file = File in
        new_file.path = path
        new_file.type = type
        new_file.content = content
        new_file.owner = current_user
        new_file.created = now()
        new_file.modified = now()
        files' = files âŠ• {path â†¦ new_file}
        result.success = true
        result.data = new_file
        
  // Delete file
  delete(path : String) : Result[ğ”¹]
    pre
      path âˆˆ dom files
      path â‰  "/"
      // Cannot delete non-empty directory
      files(path).type = directory â‡’
        Â¬âˆƒ p : dom files â€¢ parentPath(p) = path
    post
      files' = {path} â©¤ files
      result.success = true
      
  // Mount another namespace
  mount(path : String, ns : Namespace) : Result[ğ”¹]
    pre
      path âˆˆ dom files
      files(path).type = directory
      path âˆ‰ dom mounts
    post
      mounts' = mounts âŠ• {path â†¦ ns}
      result.success = true
      
  // Unmount namespace
  unmount(path : String) : Result[ğ”¹]
    pre
      path âˆˆ dom mounts
    post
      mounts' = {path} â©¤ mounts
      result.success = true
      
end Namespace

// ============================================================================
// RNDTBL Namespace Mapping
// ============================================================================

class RNDTBLNamespace extends Namespace
  graph : Graph
  
  invariant
    // Standard directory structure
    "/graph" âˆˆ dom files
    "/graph/nodes" âˆˆ dom files
    "/graph/edges" âˆˆ dom files
    "/users" âˆˆ dom files
    "/sync" âˆˆ dom files
    
  init
    root = "/rndtbl"
    createStandardStructure()
    
  // Create standard directory structure
  createStandardStructure()
    post
      files' = files âŠ•
        {"/graph" â†¦ createDirectory("/graph")} âŠ•
        {"/graph/nodes" â†¦ createDirectory("/graph/nodes")} âŠ•
        {"/graph/edges" â†¦ createDirectory("/graph/edges")} âŠ•
        {"/graph/topics" â†¦ createDirectory("/graph/topics")} âŠ•
        {"/users" â†¦ createDirectory("/users")} âŠ•
        {"/sync" â†¦ createDirectory("/sync")} âŠ•
        {"/meta" â†¦ createDirectory("/meta")}
        
  // Map graph node to file
  nodeToFile(node : Node) : File
    post
      result.path = "/graph/nodes/" + node.id + "/data"
      result.type = regular
      result.content = node.content
      result.size = node.content.size
      result.owner = node.metadata.author
      result.created = node.metadata.created
      result.modified = node.metadata.modified
      
  // Map file to graph node
  fileToNode(file : File) : Node
    pre
      file.path matches "/graph/nodes/([^/]+)/data"
    post
      result.content = file.content
      result.metadata.author = file.owner
      result.metadata.created = file.created
      result.metadata.modified = file.modified
      
  // Override lookup to handle dynamic graph files
  override lookup(path : String) : Result[File]
    post
      // Static files
      path âˆˆ dom files â‡’
        result = super.lookup(path)
        
      // Dynamic node files
      path matches "/graph/nodes/([^/]+)/data" â‡’
        let node_id = extractNodeId(path) in
          node_id âˆˆ dom graph.nodes â‡’
            result.success = true âˆ§
            result.data = nodeToFile(graph.nodes(node_id))
          node_id âˆ‰ dom graph.nodes â‡’
            result.success = false âˆ§
            result.error = "Node not found"
            
      // Dynamic edge files
      path matches "/graph/edges/([^/]+)/data" â‡’
        let edge_id = extractEdgeId(path) in
          edge_id âˆˆ dom graph.edges â‡’
            result.success = true âˆ§
            result.data = edgeToFile(graph.edges(edge_id))
          edge_id âˆ‰ dom graph.edges â‡’
            result.success = false âˆ§
            result.error = "Edge not found"
            
  // Handle write to node file
  writeNode(node_id : NodeID, content : Content) : Result[ğ”¹]
    pre
      node_id âˆˆ dom graph.nodes
    post
      graph.nodes(node_id).content' = content
      graph.nodes(node_id).metadata.modified' = now()
      result.success = true
      
end RNDTBLNamespace

// ============================================================================
// 9P Protocol Interface
// ============================================================================

// 9P message types
MessageType ::= 
  | Tversion | Rversion
  | Tauth | Rauth
  | Tattach | Rattach
  | Tflush | Rflush
  | Twalk | Rwalk
  | Topen | Ropen
  | Tcreate | Rcreate
  | Tread | Rread
  | Twrite | Rwrite
  | Tclunk | Rclunk
  | Tremove | Rremove
  | Tstat | Rstat
  | Twstat | Rwstat

class NinePMessage
  type : MessageType
  tag : â„•
  fid : â„•
  data : String
  
  invariant
    tag â‰¥ 0 âˆ§ tag < 65536
    fid â‰¥ 0
end NinePMessage

class NinePServer
  namespace : RNDTBLNamespace
  fids : â„• â†¦ String  // fid â†’ path mapping
  connections : â„• â†¦ Connection
  
  // Handle incoming 9P message
  handleMessage(msg : NinePMessage) : NinePMessage
    post
      msg.type = Tversion â‡’ result = handleVersion(msg)
      msg.type = Tattach â‡’ result = handleAttach(msg)
      msg.type = Twalk â‡’ result = handleWalk(msg)
      msg.type = Topen â‡’ result = handleOpen(msg)
      msg.type = Tread â‡’ result = handleRead(msg)
      msg.type = Twrite â‡’ result = handleWrite(msg)
      msg.type = Tclunk â‡’ result = handleClunk(msg)
      msg.type = Tstat â‡’ result = handleStat(msg)
      
  // Handle Tread - read file
  handleRead(msg : NinePMessage) : NinePMessage
    pre
      msg.fid âˆˆ dom fids
    post
      let path = fids(msg.fid)
          file_result = namespace.lookup(path)
      in
        file_result.success â‡’
          result.type = Rread âˆ§
          result.tag = msg.tag âˆ§
          result.data = file_result.data.read(offset, count).data
        Â¬file_result.success â‡’
          result.type = Rerror âˆ§
          result.data = file_result.error
          
  // Handle Twrite - write file
  handleWrite(msg : NinePMessage) : NinePMessage
    pre
      msg.fid âˆˆ dom fids
    post
      let path = fids(msg.fid)
          file_result = namespace.lookup(path)
      in
        file_result.success â‡’
          let write_result = file_result.data.write(offset, msg.data) in
            result.type = Rwrite âˆ§
            result.tag = msg.tag âˆ§
            result.data = write_result.data
        Â¬file_result.success â‡’
          result.type = Rerror âˆ§
          result.data = file_result.error
          
  // Handle Twalk - navigate path
  handleWalk(msg : NinePMessage) : NinePMessage
    pre
      msg.fid âˆˆ dom fids
    post
      let current_path = fids(msg.fid)
          walk_elements = splitPath(msg.data)
          new_path = resolvePath(current_path, walk_elements)
      in
        namespace.lookup(new_path).success â‡’
          result.type = Rwalk âˆ§
          result.tag = msg.tag âˆ§
          fids'(msg.fid) = new_path
        Â¬namespace.lookup(new_path).success â‡’
          result.type = Rerror âˆ§
          result.data = "File not found"
          
end NinePServer

// ============================================================================
// Union Mount (Namespace Composition)
// ============================================================================

class UnionNamespace extends Namespace
  layers : seq Namespace
  
  invariant
    |layers| > 0
    
  // Lookup in union - search all layers
  override lookup(path : String) : Result[File]
    post
      // Search from top layer to bottom
      let results = âŸ¨ns : layers â€¢ ns.lookup(path)âŸ© in
        âˆƒ r : results â€¢ r.success â‡’
          result = (Î¼ r : results â€¢ r.success)
        âˆ€ r : results â€¢ Â¬r.success â‡’
          result.success = false âˆ§
          result.error = "File not found in any layer"
          
  // List directory - merge from all layers
  listDirectory(path : String) : â„™ String
    post
      result = â‹ƒ {ns : layers â€¢ ns.listDirectory(path)}
      
  // Write goes to top layer only
  override create(path : String, type : FileType, content : Content) : Result[File]
    post
      result = head(layers).create(path, type, content)
      
end UnionNamespace

// ============================================================================
// Utility Functions
// ============================================================================

// Extract parent path
parentPath(path : String) : String
  post
    path = "/" â‡’ result = ""
    path â‰  "/" â‡’ result = substring(path, 0, lastIndexOf(path, "/"))

// Check for mount cycles
mountCycle(path : String, ns : Namespace) : ğ”¹
  post
    result = path âˆˆ dom ns.mounts âˆ§
             (mountCycle(path, ns.mounts(path)) âˆ¨
              âˆƒ mp : dom ns.mounts â€¢ mountCycle(mp, ns.mounts(mp)))

// Find longest mount prefix
longestMountPrefix(path : String, mounts : String â†¦ Namespace) : String
  post
    result = max({mp : dom mounts | path.startsWith(mp) â€¢ mp})

// Split path into components
splitPath(path : String) : seq String
  post
    result = split(path, "/")

// Resolve path with walk elements
resolvePath(base : String, elements : seq String) : String
  post
    elements = âŸ¨âŸ© â‡’ result = base
    head(elements) = ".." â‡’ 
      result = resolvePath(parentPath(base), tail(elements))
    head(elements) = "." â‡’
      result = resolvePath(base, tail(elements))
    otherwise â‡’
      result = resolvePath(base + "/" + head(elements), tail(elements))
