/*
 * RNDTBL Graph Specification (Z++)
 * Defines the graph structure, nodes, edges, and operations
 */

use CORE_TYPES

// ============================================================================
// Node Class
// ============================================================================

class Node
  id : NodeID
  content : Content
  metadata : Metadata
  position : Position
  visibility : Visibility
  topic : TopicID
  
  invariant
    id â‰  null
    content.size â‰¤ defaultConfig.maxNodeSize
    
  // Create a new node
  create(author : UserID, topic : TopicID, content : Content) : Node
    pre
      author â‰  null
      topic â‰  null
    post
      self.id = generateID()
      self.content = content
      self.metadata.author = author
      self.metadata.created = now()
      self.metadata.modified = now()
      self.topic = topic
  
  // Update node content
  update(user : UserID, newContent : Content) : Result[Node]
    pre
      user âˆˆ self.metadata.contributors âˆ¨ canEdit(user, self)
      newContent.size â‰¤ defaultConfig.maxNodeSize
    post
      self.content = newContent
      self.metadata.modified = now()
      self.metadata.version = self.metadata.version + 1
      self.metadata.contributors = self.metadata.contributors âˆª {user}
  
  // Check if user can view this node
  canView(user : UserID) : ğ”¹
    return
      self.visibility.type = public âˆ¨
      user âˆˆ self.visibility.allowedUsers âˆ¨
      âˆƒ g âˆˆ self.visibility.allowedGroups â€¢ user âˆˆ groupMembers(g)
  
  // Check if user can edit this node
  canEdit(user : UserID) : ğ”¹
    return
      user = self.metadata.author âˆ¨
      user âˆˆ self.metadata.contributors
      
  // Get node summary
  getSummary() : String
    return substring(self.content.data, 0, 200) + "..."
    
end Node

// ============================================================================
// Edge Class
// ============================================================================

class Edge
  id : EdgeID
  source : NodeID
  target : NodeID
  type : LinkType
  weight : â„
  metadata : Metadata
  bidirectional : ğ”¹
  
  invariant
    id â‰  null
    source â‰  null
    target â‰  null
    source â‰  target
    weight â‰¥ 0.0 âˆ§ weight â‰¤ 1.0
    
  // Create a new edge
  create(source : NodeID, target : NodeID, type : LinkType, 
         author : UserID, bidirectional : ğ”¹) : Edge
    pre
      source â‰  target
      nodeExists(source)
      nodeExists(target)
    post
      self.id = generateID()
      self.source = source
      self.target = target
      self.type = type
      self.metadata.author = author
      self.metadata.created = now()
      self.weight = 1.0
      self.bidirectional = bidirectional
      
  // Update edge weight
  updateWeight(newWeight : â„) : Result[Edge]
    pre
      newWeight â‰¥ 0.0 âˆ§ newWeight â‰¤ 1.0
    post
      self.weight = newWeight
      self.metadata.modified = now()
      
  // Reverse edge direction
  reverse() : Edge
    post
      result.source = self.target
      result.target = self.source
      result.type = self.type
      result.bidirectional = self.bidirectional
      
end Edge

// ============================================================================
// Graph Class
// ============================================================================

class Graph
  nodes : NodeID â†¦ Node
  edges : EdgeID â†¦ Edge
  adjacencyList : NodeID â†¦ â„™ EdgeID
  config : SystemConfig
  
  invariant
    // All edges reference existing nodes
    âˆ€ e : EdgeID â€¢ e âˆˆ dom edges â‡’
      edges(e).source âˆˆ dom nodes âˆ§
      edges(e).target âˆˆ dom nodes
      
    // Adjacency list is consistent with edges
    âˆ€ n : NodeID â€¢ n âˆˆ dom adjacencyList â‡’
      âˆ€ e : EdgeID â€¢ e âˆˆ adjacencyList(n) â‡’
        edges(e).source = n âˆ¨ (edges(e).target = n âˆ§ edges(e).bidirectional)
        
    // Node degree constraint
    âˆ€ n : NodeID â€¢ n âˆˆ dom adjacencyList â‡’
      |adjacencyList(n)| â‰¤ config.maxEdgesPerNode
      
  // Initialize empty graph
  init
    nodes = âˆ…
    edges = âˆ…
    adjacencyList = âˆ…
    config = defaultConfig
    
  // Add a node to the graph
  addNode(node : Node) : Result[NodeID]
    pre
      node.id âˆ‰ dom nodes
    post
      nodes' = nodes âŠ• {node.id â†¦ node}
      adjacencyList' = adjacencyList âŠ• {node.id â†¦ âˆ…}
      result.success = true
      result.data = node.id
      
  // Remove a node from the graph
  removeNode(nodeId : NodeID) : Result[ğ”¹]
    pre
      nodeId âˆˆ dom nodes
    post
      // Remove all edges connected to this node
      âˆ€ e : EdgeID â€¢ e âˆˆ dom edges âˆ§ 
        (edges(e).source = nodeId âˆ¨ edges(e).target = nodeId) â‡’
        e âˆ‰ dom edges'
        
      // Remove node and its adjacency list
      nodes' = {nodeId} â©¤ nodes
      adjacencyList' = {nodeId} â©¤ adjacencyList
      result.success = true
      
  // Add an edge to the graph
  addEdge(edge : Edge) : Result[EdgeID]
    pre
      edge.id âˆ‰ dom edges
      edge.source âˆˆ dom nodes
      edge.target âˆˆ dom nodes
      |adjacencyList(edge.source)| < config.maxEdgesPerNode
    post
      edges' = edges âŠ• {edge.id â†¦ edge}
      adjacencyList' = adjacencyList âŠ• 
        {edge.source â†¦ (adjacencyList(edge.source) âˆª {edge.id})}
      result.success = true
      result.data = edge.id
      
  // Remove an edge from the graph
  removeEdge(edgeId : EdgeID) : Result[ğ”¹]
    pre
      edgeId âˆˆ dom edges
    post
      let e = edges(edgeId) in
        adjacencyList' = adjacencyList âŠ•
          {e.source â†¦ (adjacencyList(e.source) \ {edgeId})}
        edges' = {edgeId} â©¤ edges
        result.success = true
      
  // Get all neighbors of a node
  getNeighbors(nodeId : NodeID) : â„™ NodeID
    pre
      nodeId âˆˆ dom nodes
    post
      result = {n : NodeID | 
        âˆƒ e : EdgeID â€¢ e âˆˆ adjacencyList(nodeId) âˆ§
        (edges(e).target = n âˆ¨ (edges(e).source = n âˆ§ edges(e).bidirectional))}
        
  // Find shortest path between two nodes (BFS)
  shortestPath(source : NodeID, target : NodeID) : seq NodeID
    pre
      source âˆˆ dom nodes
      target âˆˆ dom nodes
    post
      // Path exists and is shortest
      result â‰  âŸ¨âŸ© â‡’
        head(result) = source âˆ§
        last(result) = target âˆ§
        âˆ€ i : 1..len(result)-1 â€¢ result[i+1] âˆˆ getNeighbors(result[i]) âˆ§
        âˆ€ p : seq NodeID â€¢ isPath(p, source, target) â‡’ len(result) â‰¤ len(p)
      
      // No path exists
      result = âŸ¨âŸ© â‡’ Â¬reachable(source, target)
      
  // Check if target is reachable from source
  reachable(source : NodeID, target : NodeID) : ğ”¹
    return
      source = target âˆ¨
      âˆƒ n : NodeID â€¢ n âˆˆ getNeighbors(source) âˆ§ reachable(n, target)
      
  // Get subgraph containing specific nodes
  subgraph(nodeIds : â„™ NodeID) : Graph
    pre
      nodeIds âŠ† dom nodes
    post
      result.nodes = nodeIds â— nodes
      result.edges = {e : EdgeID | 
        edges(e).source âˆˆ nodeIds âˆ§ edges(e).target âˆˆ nodeIds} â— edges
      result.adjacencyList = nodeIds â— adjacencyList
      
  // Calculate clustering coefficient
  clusteringCoefficient(nodeId : NodeID) : â„
    pre
      nodeId âˆˆ dom nodes
    post
      let neighbors = getNeighbors(nodeId)
          k = |neighbors|
          connections = |{(n1, n2) : neighbors Ã— neighbors | 
                          n1 â‰  n2 âˆ§ n2 âˆˆ getNeighbors(n1)}|
      in
        k â‰¤ 1 â‡’ result = 0.0
        k > 1 â‡’ result = connections / (k * (k - 1))
        
  // Calculate betweenness centrality
  betweennessCentrality(nodeId : NodeID) : â„
    pre
      nodeId âˆˆ dom nodes
    post
      // Number of shortest paths through this node
      let allPaths = {(s, t) : (dom nodes Ã— dom nodes) | 
                      s â‰  t âˆ§ s â‰  nodeId âˆ§ t â‰  nodeId}
          pathsThrough = |{(s, t) : allPaths | 
                          nodeId âˆˆ shortestPath(s, t)}|
      in
        result = pathsThrough / |allPaths|
        
  // Find strongly connected components
  stronglyConnectedComponents() : â„™(â„™ NodeID)
    post
      // Each component is strongly connected
      âˆ€ c : result â€¢
        âˆ€ n1, n2 : c â€¢ n1 â‰  n2 â‡’ 
          reachable(n1, n2) âˆ§ reachable(n2, n1)
      
      // Components are maximal
      âˆ€ c1, c2 : result â€¢ c1 â‰  c2 â‡’ c1 âˆ© c2 = âˆ…
      
      // All nodes are in exactly one component
      â‹ƒ result = dom nodes
      
  // Detect cycles
  hasCycle() : ğ”¹
    return
      âˆƒ n : dom nodes â€¢ 
        âˆƒ path : seq NodeID â€¢ 
          len(path) > 1 âˆ§
          head(path) = n âˆ§
          last(path) = n âˆ§
          isPath(path, n, n)
          
  // Graph validation
  validate() : ValidationResult
    post
      result.valid â‡”
        // All edge endpoints exist
        (âˆ€ e : dom edges â€¢ 
          edges(e).source âˆˆ dom nodes âˆ§ 
          edges(e).target âˆˆ dom nodes) âˆ§
        // Adjacency list is consistent
        (âˆ€ n : dom adjacencyList â€¢
          âˆ€ e : adjacencyList(n) â€¢ e âˆˆ dom edges) âˆ§
        // No self-loops
        (âˆ€ e : dom edges â€¢ edges(e).source â‰  edges(e).target) âˆ§
        // Degree constraints satisfied
        (âˆ€ n : dom adjacencyList â€¢ 
          |adjacencyList(n)| â‰¤ config.maxEdgesPerNode)
          
end Graph

// ============================================================================
// Graph Operations
// ============================================================================

// Merge two graphs
merge(g1 : Graph, g2 : Graph) : Graph
  post
    result.nodes = g1.nodes âŠ• g2.nodes
    result.edges = g1.edges âŠ• g2.edges
    // Rebuild adjacency list
    âˆ€ n : dom result.nodes â€¢
      result.adjacencyList(n) = 
        {e : dom result.edges | result.edges(e).source = n}

// Graph union
union(g1 : Graph, g2 : Graph) : Graph
  post
    result.nodes = g1.nodes âˆª g2.nodes
    result.edges = g1.edges âˆª g2.edges

// Graph intersection  
intersection(g1 : Graph, g2 : Graph) : Graph
  post
    result.nodes = g1.nodes âˆ© g2.nodes
    result.edges = g1.edges âˆ© g2.edges

// Graph difference
difference(g1 : Graph, g2 : Graph) : Graph
  post
    result.nodes = g1.nodes \ g2.nodes
    result.edges = g1.edges \ g2.edges
